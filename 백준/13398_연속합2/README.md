두 가지 dp배열을 사용한다.
1. dp[0][N] - 숫자를 하나도 빼지 않은 연속합
2. dp[1][N] - 숫자를 하나 뺀 연속합

dp[0]배열은 다음 과정을 거친다.
i = 0부터 반복을 돌며 다음을 판단한다.
1. dp[i] = dp[i - 1] + arr[i]으로 누적합을 구한다.
2. 그러다 dp[i - 1] + arr[i]보다 arr[i]가 크면 새로운 **연속의 시작**으로 판달할 수 있다.
    * i - 1까지의 누적합이 -10인데 i번째 숫자가 -5면 -5부터 다시 시작하는 것이 더 큰 연속합을 만들 수 있다.
-> dp[0][i] = max(dp[i - 1] + arr[i], arr[i])

dp[1]배열은 다음으로 판단할 수 있다.
1. dp[1][i - 1]은 이미 숫자를 하나 제거한 배열 중 합이 가장 큰 배열이다.
    -> dp[1][i - 1] + arr[i]는 자기자신(i번째) 수를 제거하지 않은 배열의 연속합이다.
2. dp[0][i - 1]은 숫자를 아직 제거하지 않은 배열 중 합이 가장 큰 배열이다.
    -> dp[0][i - 1]은 자기자신(i번째) 수를 제거한 배열의 연속합니다.
-> dp[1][i] = max(dp[1][i - 1] + arr[i], dp[0][i - 1]);